/**
 * @file arm.h
 *
 * arm.h contains routines to let C code use ARM specific instructions
 * and data structures.
 *
 *  @author Zhiyi Huang, University of Otago, hzy@cs.otago.ac.nz
 * (Adaption from MIT XV6.)
 *
 * @author H Paterson, University of Otago, patha454@student.otago.ac.nz
 * (Documentation, styling, and refactoring.)
 *
 * @date 14/11/2018
 */



/** CPSR/SPSR mode bits for user mode. */
#define PSR_MODE_USR 0x10

/** CPSR/SPSR mode bits for fast interrupt mode. */
#define PSR_MODE_FIQ 0x11

/** CPSR/SPSR mode bits for interrupt mode. */
#define PSR_MODE_IRQ 0x12

/** CPSR/SPSR mode bits for supervisor mode. */
#define PSR_MODE_SVC 0x13

/** CPSR/SPSR mode bits for monitor mode. */
#define PSR_MODE_MON 0x16

/** CPSR/SPSR mode bits for (instruction prefetch) abort mode. */
#define PSR_MODE_ABT 0x17

/** CPSR/SPSR mode bits for undefined (instruction) abort mode. */
#define PSR_MODE_UND 0x1B

/** CPSR/SPSR mode bits for system mode. */
#define PSR_MODE_SYS 0x1F

/** CPSR/SPSR mode bit pattern for user mode. */
#define PSR_USER_MODE 0x0

/** CPSR/SPSR mode bit mask. */
#define PSR_MASK 0x1F



/** Program status register 'mask IRQ' bit. */
#define PSR_DISABLE_IRQ	0x00000080

/** Program status register 'mask FIQ' bit. */
#define PSR_DISABLE_FIQ	0x00000040

/** Program status register overflow condition bit. */
#define PSR_V 0x10000000

/** Program status register carry condition bit. */
#define PSR_C 0x20000000

/** Program status register zero condition bit. */
#define PSR_Z 0x40000000

/** Program status register negative condition bit. */
#define PSR_N 0x80000000


/**
 * Reads a word located at a specified memory address.
 *
 * inw ("Input Word") reads and returns the word located at a
 * specified memory address.
 *
 * @param addr - The address to read from.
 * @return The word located at 'addr' in the memory.
 */
static inline u_int32 inw(u_int32 addr)
{
    u_int32 data;
    asm volatile("ldr %0,[%1]" : "=r"(data) : "r"(addr));
    return data;
}


/**
 * Writes a word to a specific memory address.
 *
 * outw ("Output Word") writes a word into a specific address
 * in the memory.
 *
 * @param addr - The address to write 'data' to.
 * @param data - The word to write to 'addr'.
 */
static inline void outw(u_int32 addr, u_int32 data)
{
    asm volatile("str %1,[%0]" : : "r"(addr), "r"(data));
}


/**
 * @struct trapframe - The layout of a trap frame on the stack.
 *
 * 'trapframe' describes the layout of the trap frame, so that
 * individual variables can be easily read and written in C,
 * assuming we have a pointer to the top of the trap frame -
 * which will often be at the top (lowest address) of the stack.
 *
 * The trap frame is generated by _switchtosvc and do_svc in
 * exception.S, and passed to trap() in trap.c
 *
 * @see do_svc & _switchtosvc in exception.S.
 * @see trap() in trap.c.
 */
// Layout of the trap frame built on the stack
// by exception.s, and passed to trap().
struct trapframe {
  u_int32 sp;        /**< User mode stack pointer. */
  u_int32 r0;
  u_int32 r1;
  u_int32 r2;
  u_int32 r3;
  u_int32 r4;
  u_int32 r5;
  u_int32 r6;
  u_int32 r7;
  u_int32 r8;
  u_int32 r9;
  u_int32 r10;
  u_int32 r11;
  u_int32 r12;
  u_int32 r13;      /**< r13 is also used as the stack pointer. (SP is a banked r13 alias.) */
  u_int32 r14;      /**< User mode link register. */
  u_int32 trapno;   /**< Trap number indicating the type of trap. */
  u_int32 ifar;     /**< Instruction Fault Address Register (IFAR) */
  u_int32 cpsr;     /**< CPSR from the trap handeler indicating CPU mode. */
  u_int32 spsr;     /** Saved CPSR from the trapped/interrupted mode. */
  u_int32 pc;       /**< Return address of the interrupted code. */
};
