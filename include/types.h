/**
 * @file types.h
 *
 * types.h provides type definitions for common and miscellaneous types
 * used in the xv6 ARM port.
 *
 * @author Zhiyi Huang, University of Otago, hzy@cs.otago.ac.nz
 * (Adaption from MIT XV6.)
 *
 * @author H Paterson, University of Otago, patha454@student.otago.ac.nz
 * (Documentation and refactoring.)
 *
 * @date 18/10/2018
 */


 /** Abbreviation for a 32 bit unsigned integer. */
typedef unsigned int u_int32;

/** Abbreviation for a 16 bit unsigned integer. */
typedef unsigned short u_short16;

/** Abbreviation for an 8 bit unsigned integer. */
typedef unsigned char u_char8;


/** Type for page directory entries. */
typedef u_int32 pde_t;

/** Type for page table entries. */
typedef u_int32 pte_t;


/**
 * @struct Vpage0 - Defines the layout of the trap vectors.
 *
 * The trap vector contains pointers to routines for handling
 * different traps, such as interrupt (IRQ) and fast interrupt (FRQ),
 * which can be generated by the hardware.
 *
 * The trap vector is double mapped into virtual memory at addresses
 * HVECTORS and KZERO (0x80000000)
 *
 * @see exception.s - where the label 'vectors' is defined and trap
 * procedures are defined.
 *
 * @see tvinit (trap.c) - where the trap vector is copied into KZERO.
 */
typedef struct Vpage0 {
    /** @var vectors - The table of function pointers to the trap handlers.
     *
     * These are the 'ldr pc, ${HANDLER}' instructions in 'exception.s'.
     *
     * @note 'vectors' is a pointer to an array of void(void) function pointers.
     */
    void (*vectors[8])(void);

    /** @var vtable - The addresses of the handler assembly routines.
     *
     * These are the .word variables in 'exception.s' which store the address of
     * each handler.
     */
    u_int32 vtable[8];
} Vpage0;


/**
 * @struct int_ctrl_regs - ('Interrupt Control Registers') Defines the layout of the
 * interrupt control Registers.
 *
 * On the BCM2835 SoC (RPI), the ARM interrupt control registers are memory
 * mapped.
 *
 * Each address refers to a 32 bit control register.
 *
 * Refer to the 'BCM2835 ARM Peripherals' document from Broadcom, Section 7.5.
 */
/* ARM interrupt control registers */
typedef struct int_ctrl_regs {
    /** @var irq_basic_pending - Shows which IRQ interrupts are pending. */
    u_int32  irq_basic_pending;

    /**
     * @var irq_pending - Indicates which devices have interrupts pending.
     *
     * These are also called "GPU pending" registers in the BCM datasheet,
     * because most of these refer to GPU interrupt sources.*/
    u_int32  irq_pending[2];

    /**
     * @var fiq_control - Sets which source can generate a FIQ.
     *
     * When enabling FIQ for a source, ensure IRQ is disabled
     * for the same source. Otherwise, one event will fire an
     * IRQ and FIQ at the same time - this is bad.
     * */
    u_int32  fiq_control;

    /** @var irq_enable - Interrupt enable register 1 & 2.
     *
     * These two registers set which devices can fire interrupts which will
     * are visible in the 'irq_pending' registers.
     */
    u_int32  irq_enable[2];

    /** @var irq_basic_enable - Basic interrupt enable register.
     *
     * Controls which devices' interrupts are visible in the 'irq_basic_pending'
     * register.
     */
    u_int32  irq_basic_enable;

    /** @var irq_disable - Disables IRQ devices' interrupts from being visible. */
    u_int32  irq_disable[2];

    /** @var irq_basic_disable - Disables basic interrupts from being visible. */
    u_int32  irq_basic_disable;
} int_ctrl_regs;


/** @struct frame_buf_desc - Stores a frame buffer description. */
typedef struct frame_buf_desc {
	u_int32 width;      /**< Width. */
	u_int32 height;     /**< Height. */
	u_int32 v_width;    /**< Virtual width. */
	u_int32 v_height;   /**< Virtual height. */
	u_int32 pitch;      /**< GPU pitch. */
	u_int32 depth;      /**< Bit depth. */
	u_int32 x;
	u_int32 y;
	u_int32 fbp;        /**< GPU framebuffer pointer. */
	u_int32 fbs;        /**< GPY framebuffer size. */
} frame_buf_desc;

